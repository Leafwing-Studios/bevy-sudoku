/// Sudoku generation logic
use crate::aesthetics::{FillableFont, FixedFont};
use crate::board::{Cell, Coordinates, DisplayedBy, Fixed, Value};
use crate::utils::SudokuStage;
use bevy::prelude::*;
use bevy::utils::HashMap;
use sudoku::Sudoku;

pub struct GenerationPlugin;

impl Plugin for GenerationPlugin {
    fn build(&self, app: &mut AppBuilder) {
        app.add_startup_system(generate_sudoku.system())
            .add_startup_system_to_stage(SudokuStage::PostStartup, fill_puzzle.system())
            .add_system(style_numbers.system())
            .add_system(cheat_at_sudoku.system());
    }
}

/// The clues and constraints given by the puzzle
#[derive(Debug)]
struct InitialPuzzle {
    numbers: HashMap<Coordinates, Value>,
}
/// The true solution to the puzzle
struct CompletePuzzle {
    numbers: HashMap<Coordinates, Value>,
}

fn parse_sudoku(sudoku: Sudoku) -> HashMap<Coordinates, Value> {
    let (mut row, mut column) = (1, 0);
    let mut map = HashMap::default();

    // Sudoku::iter() goes from left to right, top to bottom
    for val in sudoku.iter() {
        column += 1;
        if column == 10 {
            row += 1;
            column = 1;
        }
        let square = Coordinates::compute_square(row, column);

        let coordinates = Coordinates {
            row,
            column,
            square,
        };
        let value = Value(val);
        map.insert(coordinates, value);
    }
    map
}

/// Creates a new sudoku using the `sudoku` crate
fn generate_sudoku(mut commands: Commands) {
    let completed = Sudoku::generate_filled();
    // Puzzles are generated by removing clues
    let initial = Sudoku::generate_unique_from(completed);

    commands.insert_resource(InitialPuzzle {
        numbers: parse_sudoku(initial),
    });
    commands.insert_resource(CompletePuzzle {
        numbers: parse_sudoku(completed),
    });
}

fn fill_puzzle(
    initial_puzzle: Res<InitialPuzzle>,
    mut query: Query<(&Coordinates, &mut Value, &mut Fixed), With<Cell>>,
) {
    for (coordinates, mut value, mut is_fixed) in query.iter_mut() {
        let initial_value = initial_puzzle.numbers.get(coordinates).unwrap();

        // Fill in cells from initial puzzle and mark those cells as fixed
        if initial_value.0.is_some() {
            *value = *initial_value;
            is_fixed.0 = true;
        }
    }
}

fn style_numbers(
    cell_query: Query<(&Fixed, &Relation<DisplayedBy>), Changed<Fixed>>,
    mut text_query: Query<&mut Text>,
    fixed_font_res: Res<FixedFont>,
    fillable_font_res: Res<FillableFont>,
) {
    for (is_fixed, displayed_by) in cell_query.iter() {
        for (text_entity, _) in displayed_by {
            let mut text = text_query.get_mut(text_entity).unwrap();
            text.sections[0].style.font = match is_fixed.0 {
                true => fixed_font_res.0.clone(),
                false => fillable_font_res.0.clone(),
            }
        }
    }
}

/// Cheats and fills in the solution for you when space is pressed
fn cheat_at_sudoku(
    complete_puzzle: Res<CompletePuzzle>,
    mut query: Query<(&Coordinates, &mut Value), With<Cell>>,
    keyboard_input: Res<Input<KeyCode>>,
) {
    if keyboard_input.just_pressed(KeyCode::Space) {
        for (coordinates, mut value) in query.iter_mut() {
            let correct_value = complete_puzzle.numbers.get(coordinates).unwrap();

            // Fill in cells from initial puzzle and mark those cells as fixed
            *value = *correct_value;
        }
    }
}
