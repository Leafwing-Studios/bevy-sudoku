/// Sudoku generation logic
use crate::input::buttons::{NewPuzzle, ResetPuzzle, SolvePuzzle};
use crate::logic::board::{Cell, Coordinates, Fixed, Value};
use bevy::prelude::*;
use bevy::utils::HashMap;
use std::ops::DerefMut;
use sudoku::Sudoku;

pub struct GenerationPlugin;

impl Plugin for GenerationPlugin {
    fn build(&self, app: &mut AppBuilder) {
        app.init_resource::<InitialPuzzle>()
            .init_resource::<CompletePuzzle>()
            .add_startup_system(first_sudoku.system())
            .add_system(fill_puzzle.system().label(GenerationLabels::FillPuzzle))
            // Must occur before we fill the puzzle to ensure
            // that the new puzzle has been generated before we attempt to fill it
            .add_system(new_sudoku.system().before(GenerationLabels::FillPuzzle))
            .add_system(reset_sudoku.system())
            .add_system(solve_sudoku.system());
    }
}

#[derive(SystemLabel, Clone, Hash, Copy, PartialEq, Eq, Debug)]
enum GenerationLabels {
    FillPuzzle,
}

// QUALITY: refactor to share data with CompletePuzzle struct
/// The clues and constraints given by the puzzle
#[derive(Default)]
struct InitialPuzzle {
    numbers: HashMap<Coordinates, Value>,
}
/// The true solution to the puzzle
#[derive(Default)]
struct CompletePuzzle {
    numbers: HashMap<Coordinates, Value>,
}

/// Converts a sudoku generated by the `sudoku` crate into a usable format
fn parse_sudoku(sudoku: Sudoku) -> HashMap<Coordinates, Value> {
    let (mut row, mut column) = (1, 0);
    let mut map = HashMap::default();

    // Sudoku::iter() goes from left to right, top to bottom
    for value in sudoku.iter() {
        column += 1;
        if column == 10 {
            row += 1;
            column = 1;
        }
        let square = Coordinates::compute_square(row, column);

        let coordinates = Coordinates {
            row,
            column,
            square,
        };

        let value = match value {
            Some(v) => Value::Filled(v),
            None => Value::Empty,
        };
        map.insert(coordinates, value);
    }
    map
}

/// Sends an event to create a new sudoku on app startup
fn first_sudoku(mut event_writer: EventWriter<NewPuzzle>) {
    event_writer.send(NewPuzzle::default());
}

/// Creates a new sudoku using the `sudoku` crate
fn new_sudoku(
    mut event_reader: EventReader<NewPuzzle>,
    mut initial_puzzle: ResMut<InitialPuzzle>,
    mut complete_puzzle: ResMut<CompletePuzzle>,
) {
    for _ in event_reader.iter() {
        let completed = Sudoku::generate_filled();
        // Puzzles are generated by removing clues
        let initial = Sudoku::generate_unique_from(completed);

        *initial_puzzle = InitialPuzzle {
            numbers: parse_sudoku(initial),
        };
        *complete_puzzle = CompletePuzzle {
            numbers: parse_sudoku(completed),
        };
    }
}

/// Fills fixed values from the puzzle into the board
fn fill_puzzle(
    initial_puzzle: Res<InitialPuzzle>,
    mut query: Query<(&Coordinates, &mut Value, &mut Fixed), With<Cell>>,
) {
    // Only run when the puzzle is changed
    if !initial_puzzle.is_changed() {
        return;
    }

    for (coordinates, mut value, mut is_fixed) in query.iter_mut() {
        let initial_value = initial_puzzle
            .numbers
            .get(coordinates)
            .expect("No values found in puzzle for these coordinates");

        // Fill in cells from initial puzzle and mark non-empty cells as fixed
        *value = initial_value.clone();
        is_fixed.0 = !(*initial_value == Value::Empty);
    }
}

/// Resets the puzzle to its original state
fn reset_sudoku(
    mut event_reader: EventReader<ResetPuzzle>,
    mut initial_puzzle: ResMut<InitialPuzzle>,
) {
    for _ in event_reader.iter() {
        // Flags the puzzle as having changed, causing the fill_puzzle system to reset all values
        // as if a new identical puzzle had been generated
        // QUALITY: use an explicit set_changed() method instead once added, see https://github.com/bevyengine/bevy/pull/2208
        initial_puzzle.deref_mut();
    }
}

/// "Solves" the given Sudoku by looking up the solution
fn solve_sudoku(
    mut event_reader: EventReader<SolvePuzzle>,
    complete_puzzle: Res<CompletePuzzle>,
    mut query: Query<(&Coordinates, &mut Value), With<Cell>>,
) {
    for _ in event_reader.iter() {
        for (coordinates, mut value) in query.iter_mut() {
            let correct_value = complete_puzzle
                .numbers
                .get(coordinates)
                .expect("No values found in puzzle for these coordinates");

            // Fill in cells from initial puzzle and mark those cells as fixed
            *value = correct_value.clone();
        }
    }
}
